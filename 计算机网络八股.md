# 计算机网络八股

------

### http无状态体现在哪？

HTTP的无状态体现在每个请求之间相互独立，服务器不会保留之前请求的状态信息。每次客户端向服务器发送请求时，服务器都会独立处理该请求，不会记住之前的请求信息或状态。

这意味着服务器无法知道两次请求是否来自同一个客户端，也无法知道客户端的历史状态，需要通过其他机制（如Cookies、Session）来维护和管理状态信息。

`Cookie` 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

相当于，**在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了**，

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfQFwefcVKVTArNRnzbZ8CBvBV7OY9zQ6K0UVR7AX1hiaLmS90iaL1zMsiaflIdeJfKib8z0TM3VKN6kg/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)Cookie 技术

### Cookie和session的区别是什么？

- **存储位置**：Cookie存储在客户端（浏览器）中，而Session存储在服务器端。
- **安全性**：由于Cookie存储在客户端，因此容易受到安全攻击，如跨站脚本攻击（XSS）和跨站请求伪造（CSRF）。而Session存储在服务器端，对客户端不可见，相对来说更安全。
- **存储容量**：Cookie的存储容量有限，通常为4KB左右，而Session的存储容量较大，受限于服务器的配置。



### 对称加密和非对称加密的区别？

**对称加密**只使用一个密钥进行加解密，优点是运算速度快，缺点是密钥必须保密，无法做到安全的密钥交换。

**非对称加密**使用两个密钥：公钥和私钥。公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。公钥和私钥都可以用来加密和解密，流程的不同，意味着目的也不相同：

- **公钥加密，私钥解密**。这个目的是为了**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
- **私钥加密，公钥解密**。这个目的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。

一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。



### 你分别了解哪些对称加密和非对称加密的算法？

对称加密算法包括：

- **AES**：对称加密算法中最流行和广泛使用的算法之一，支持不同的密钥长度（如AES-128、AES-256）。
- **DES（Data Encryption Standard）**：数据加密标准，速度较快，适用于加密大量数据的场合。

非对称加密算法包括：

- **RSA**：最常见的非对称加密算法，用于数据加密和数字签名。
- **DSA（Digital Signature Algorithm）**：数字签名算法，是一种标准的 DSS（数字签名标准）
- **ECC**：基于椭圆曲线的非对称加密算法，具有较高的安全性和效率，适用于移动设备等资源受限的环境。



### 在信息传输过程中，Https用的是对称加密还是非对称加密？

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfoVlP0ftECq7GBqNkxA95EBPItrNxdj5EMlNQErGKoEaezpYhxttmc361M746pOIicgTEQiaTBYQmA/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)混合加密

HTTPS 采用的是**对称加密**和**非对称加密**结合的「混合加密」方式：

- 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
- 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。



### 三次握手过程介绍一下

TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而**建立连接是通过三次握手来进行的**。三次握手的过程如下图：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfao8qtpmKRfSDiaXDJQjw7icPSrrLA4OqibxlU6cOiaoiaXtRo4yD8dBe76iby6PTvmxuBmxNyqiaicu8DKw/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)TCP 三次握手

- 一开始，客户端和服务端都处于 `CLOSE` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态
- 客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1`，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。
- 服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态。
- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 `ESTABLISHED` 状态。
- 服务端收到客户端的应答报文后，也进入 `ESTABLISHED` 状态。

一旦完成三次握手，双方都处于 `ESTABLISHED` 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。



### HTTPS 四次握手过程说一下

> 也可参考小林coding的内容：[4.1 TCP 三次握手与四次挥手面试题 | 小林coding (xiaolincoding.com)](https://www.xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-四次挥手过程是怎样的)

SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信。

前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。

基于 RSA 算法的 TLS 握手过程比较容易理解，所以这里先用这个给大家展示 TLS 握手过程，如下图：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/J0g14CUwaZfoVlP0ftECq7GBqNkxA95E7mDcJ7cPpLY6g3KJvOqI3yxhyicFVO3twF2d8icmbWqltYpeico3NibXWw/640?wx_fmt=jpeg&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)HTTPS 连接建立过程

TLS 协议建立的详细流程：

*1. ClientHello*

首先，由客户端向服务器发起加密通信请求，也就是 `ClientHello` 请求。

在这一步，客户端主要向服务器发送以下信息：

（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。

（2）客户端生产的随机数（`Client Random`），后面用于生成「会话秘钥」条件之一。

（3）客户端支持的密码套件列表，如 RSA 加密算法。

*2. SeverHello*

服务器收到客户端请求后，向客户端发出响应，也就是 `SeverHello`。服务器回应的内容有如下内容：

（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。

（2）服务器生产的随机数（`Server Random`），也是后面用于生产「会话秘钥」条件之一。

（3）确认的密码套件列表，如 RSA 加密算法。

（4）服务器的数字证书。

*3.客户端回应*

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

如果证书没有问题，客户端会**从数字证书中取出服务器的公钥**，然后使用它加密报文，向服务器发送如下信息：

（1）一个随机数（`pre-master key`）。该随机数会被服务器公钥加密。

（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。

**服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**。

*4. 服务器的最后回应*

服务器收到客户端的第三个随机数（`pre-master key`）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。

然后，向客户端发送最后的信息：

（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。



### Https客户端校验证书的细节？

如下图图所示，为数字证书签发和验证流程：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfoVlP0ftECq7GBqNkxA95E6ic9EaZpfbiasSTUf8gTf9e0h98OPrvvq7EvZrITUicYI5ydRX8TGVic7w/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)img

CA 签发证书的过程，如上图左边部分：

- 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；
- 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；
- 最后将 Certificate Signature 添加在文件证书上，形成数字证书；

客户端校验服务端的数字证书的过程，如上图右边部分：

- 首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
- 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；
- 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。

但事实上，证书的验证过程中**还存在一个证书信任链的问题**，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfoVlP0ftECq7GBqNkxA95EXGiaNtI9n8IOe1icSeKGKm8YgO6TaNGibX54b697d4QkcjQ9AibhW6zXcw/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

对于这种三级层级关系的证书的验证过程如下：

- 客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。
- 请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。
- “GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。

在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。

总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfoVlP0ftECq7GBqNkxA95Ey5w2qv8u6YtjN30XvohHSkG9W9f0WLibyduj091AXMqCo4lSLiccKfYw/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

操作系统里一般都会内置一些根证书，比如我的 MAC 电脑里内置的根证书有这么多：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfoVlP0ftECq7GBqNkxA95EsDic0iaW9D8yzsLd6jTB8DSHBnagseJskjnY87szVhNUniboXqsr74GmQ/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfoVlP0ftECq7GBqNkxA95EDO83rBiaqwl3vBcTyQ9IzCLnRDu5ASAehlPAk7MsT0kGmCZxH1tuYsA/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)



### 浏览器键入网址全过程？

输入URL过程如下：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZfQRicpOgAh6Vj9bLDxk52h8eT5j97njCmniags00TEqvdK5Ep8OF802TGN64OdIeqjzWaawDozVreQ/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)

- DNS 解析：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址。
- TCP 连接：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接。
- 建立TCP协议时，需要发送数据，发送数据在网络层使用IP协议， 通过IP协议将IP地址封装为IP数据报；然后此时会用到ARP协议，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址；
- IP数据包在路由器之间，路由选择使用OPSF协议， 采用Dijkstra算法来计算最短路径树，抵达服务端。
- 发送 HTTP 请求：建立 TCP 连接之后，浏览器向 Web 服务器发起一个 HTTP 请求（如果是HTTPS协议，发送HTTP 请求之前还需要完成TLS四次握手）；
- 处理请求并返回：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。
- 浏览器渲染：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。
